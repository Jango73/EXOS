# x86-64 Support Roadmap

## Objectives
- Introduce an x86-64 build target while keeping the existing i386 path stable during the transition.
- Share as much common code as possible through architecture-neutral abstractions.
- Provide a clear migration path for kernel subsystems that currently assume 32-bit semantics.

## Refactoring & Abstractions
1. **Build System**
   - Split architecture-specific compiler flags, linker scripts, and object lists into `scripts/toolchain/<arch>/` or per-arch make fragments.
   - Add an `ARCH` variable to the top-level Makefile and propagate it to sub-makefiles, assembly rules, and scripts.
   - Produce one kernel binary per supported architecture; maintain separate linker scripts (`kernel/linker/i386.ld`, `kernel/linker/x86-64.ld`).
2. **Boot & Startup Code**
   - Isolate real-mode and protected-mode boot logic in `boot-*` directories; create `boot/x86-64/` with 64-bit long-mode transition code.
   - Keep the existing BIOS bootloader as the base and extend it to enter long mode before transferring control to the x86-64 kernel.
   - Factor common disk-loading routines into shared modules to avoid duplication across architectures.
3. **Architecture Layer (`arch/`)**
   - Create `kernel/source/arch/i386/` and `kernel/source/arch/x86-64/` for CPU-specific code (interrupt stubs, GDT/IDT/TSS setup, MSR handling).
   - Wrap architecture entry points behind an `ArchOps` table that exposes initialization, interrupt management, context switch helpers, and CPU feature detection.
4. **Interrupt and Exception Handling**
   - Separate ISR stubs (`Interrupt-a.asm`, etc.) into per-arch directories; expose architecture-neutral registration in `Interrupt.c`.
   - Adjust `Fault.c` to rely on architecture-provided trap frame structures.
5. **Task & Process Structures**
   - Decouple task control blocks from fixed-width registers; move register definitions into per-arch headers.
   - Provide conversion helpers to translate between user ABI contexts and kernel scheduler structures.
6. **Memory Management Layer**
   - Abstract page table manipulation behind `MmArch` interface. Keep current 32-bit paging implementation under `arch/i386/mm/` and add new 4-level paging implementation under `arch/x86-64/mm/`.

## New Features & Capabilities
- 64-bit long mode boot sequence, including identity-mapped trampoline and relocation of the kernel above 4 GiB.
- CPU feature detection for x86-64 (CPUID leafs for long mode, NX bit, SSE/AVX capabilities).
- Support for `syscall/sysret` fast system call path in addition to legacy `int 0x80`.
- Expanded interrupt descriptor table to 64-bit gate descriptors.
- Per-CPU data structures and GS-based access for scheduler data.
- Updated user-space ABI to LP64 (pointer and size types promoted to 64 bits) once userland binaries are ready; keep current 32-bit userland unchanged during the initial kernel bring-up.
- ELF loader capable of handling 64-bit binaries (ELFCLASS64, new relocation types) while retaining 32-bit support for existing userland until it is ported.

## Additional Processor Instructions
- Long mode control-flow instructions: `SYSCALL`, `SYSRET`, `SYSENTER`, `SYSEXIT` (with compatibility fallback).
- Model specific register operations: `WRMSR`, `RDMSR` for EFER.LME, STAR, LSTAR, FMASK, GS base.
- `SWAPGS` for user/kernel GS switching.
- SIMD context preservation: `FXSAVE/FXRSTOR` or `XSAVE/XSAVEOPT` depending on CPUID support.
- `HLT`, `PAUSE`, and `RDFSBASE/WRFSBASE` for optimized idle loops when available.

## Memory Management Evolution
1. **Address Space Layout**
   - Define canonical address ranges for kernel (higher half, e.g., `FFFF8000_00000000`) and user space (lower canonical half).
   - Reserve guard gaps and per-CPU stacks leveraging large virtual address space.
2. **Paging Structures**
   - Implement 4-level paging (PML4, PDPT, PD, PT) with 48-bit virtual addresses and support for huge pages (2 MiB, 1 GiB if hardware permits).
   - Update page allocator to manage physical addresses above 4 GiB and to understand 64-bit frame numbers.
3. **Memory Map Discovery**
   - Extend bootloader to pass EFI/BIOS memory map entries with 64-bit base/length values.
   - Use page attribute table (PAT) and NX support; update protection flags to include execute disable.
4. **Kernel Heap & Slab Allocator**
   - Ensure size_t and pointer arithmetic functions operate with 64-bit values.
   - Expand buddy allocator metadata to hold 64-bit physical addresses.

## Context Switch Evolution
1. **Register Set**
   - Save/restore 64-bit general-purpose registers (RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, R8-R15).
   - Preserve segment registers, RFLAGS, RIP, and MXCSR via `FXSAVE` or `XSAVE`.
   - Manage FS/GS base MSRs for user threads; ensure `SWAPGS` and `WRMSR` usage on kernel entry/exit.
2. **Stack & Calling Convention**
   - Align stacks to 16 bytes per System V AMD64 ABI before calling user-mode.
   - Maintain separate interrupt stack tables (IST) in the TSS for critical faults (NMI, double fault, #MC).
3. **Scheduler Integration**
   - Update task state structures to store 64-bit stack pointers and instruction pointers.
   - Revise context switch assembly to use `iretq` and long-mode descriptor formats.
   - Ensure per-CPU scheduler state uses GS-based references for quick access.

## Testing & Tooling
- Add QEMU scripts for `qemu-system-x86-64` with appropriate machine options (e.g., `-cpu qemu64,+sse4.2,+xsave`).
- Provide GDB multi-arch support (`set architecture i386:x86-64`).
- Integrate unit tests or CI steps that build both i386 and x86-64 kernels to prevent regressions.

## Decisions
- Ship separate kernel binaries for each supported architecture (i386 and x86-64) to keep build artifacts simple and tailored.
- Defer userland ABI migration; adapt userland binaries to LP64 after the kernel and tooling support are in place.
- Reuse the current BIOS bootloader, extending it as needed to enter long mode for the x86-64 kernel path.
